<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometry Dash Full - Yusuf</title>
<style>
body { margin:0; overflow:hidden; background:#111; font-family:sans-serif; }
canvas { display:block; margin:auto; background:#111; }
#score { position:absolute; top:20px; left:50%; transform:translateX(-50%); color:#0f0; font-size:24px; font-weight:bold; text-shadow:0 0 2px #000; }
#startScreen { position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; background:#111; color:#0f0; }
button { padding:15px 30px; font-size:20px; margin-top:20px; cursor:pointer; border:none; border-radius:10px; background:#0f0; color:#000; font-weight:bold; }
button:hover { background:#0a0; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="startScreen">
<h1>Geometry Dash Mini</h1>
<p>Click Play or press Space to start</p>
<button id="playBtn">Play</button>
</div>
<canvas id="game" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const startScreen = document.getElementById('startScreen');
const playBtn = document.getElementById('playBtn');

// Game variables
let gameRunning = false;
let player = { x:100, y:300, w:30, h:30, vy:0, jumping:false };
let gravity = 0.8, jumpPower = -15;
let platforms = [], obstacles = [];
platforms.push({ x:0, y:350, w:canvas.width, h:50 });
let bgLayers = [
    { x:0, y:0, w:canvas.width, h:canvas.height, speed:0.2, color:'#4400ff' },
    { x:0, y:0, w:canvas.width, h:canvas.height, speed:0.5, color:'#8800ff' },
    { x:0, y:0, w:canvas.width, h:canvas.height, speed:1, color:'#ff0088' }
];
let spawnTimer = 0, speed = 5, score = 0, highScore = 0, gameOver = false;

// Controls
document.addEventListener('keydown', e => { if(e.code==='Space'){ if(!gameRunning) startGame(); else jump(); } });
canvas.addEventListener('click', ()=>{ if(!gameRunning) startGame(); else jump(); });
playBtn.addEventListener('click', startGame);

// Start game
function startGame() {
    startScreen.style.display='none';
    gameRunning = true;
    resetGame();
    update();
}

// Reset game
function resetGame() {
    player.y = 300; player.vy = 0; player.jumping = false;
    obstacles = []; platforms = [{ x:0, y:350, w:canvas.width, h:50 }];
    spawnTimer = 0; speed = 5; score = 0; gameOver = false;
}

// Player jump
function jump() {
    if(!player.jumping) { player.vy = jumpPower; player.jumping = true; }
}

// Draw functions
function drawBackground() {
    bgLayers.forEach(layer => {
        ctx.fillStyle = layer.color;
        ctx.fillRect(layer.x, layer.y, layer.w, layer.h);
        ctx.fillRect(layer.x + canvas.width, layer.y, layer.w, layer.h);
        layer.x -= layer.speed;
        if(layer.x <= -canvas.width) layer.x = 0;
    });
}

function drawPlatforms() {
    platforms.forEach(p => {
        ctx.fillStyle = '#0f0';
        ctx.fillRect(p.x, p.y, p.w, p.h);
    });
}

function drawObstacles() {
    obstacles.forEach(obs => {
        drawSpike(obs.x, obs.y, obs.w, obs.h);
    });
}

function drawSpike(x, y, w, h) {
    ctx.fillStyle = '#f00';
    ctx.beginPath();
    ctx.moveTo(x, y + h);
    ctx.lineTo(x + w/2, y);
    ctx.lineTo(x + w, y + h);
    ctx.closePath();
    ctx.fill();
}

function drawPlayer() {
    ctx.fillStyle = '#0f0';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.strokeRect(player.x, player.y, player.w, player.h);
}

// Spawn obstacles with multiple patterns
function spawnObstacle() {
    const patterns = [
        [{x:0,y:0,w:30,h:30}],
        [{x:0,y:0,w:30,h:50}],
        [{x:0,y:0,w:30,h:70}],
        [{x:0,y:0,w:30,h:40},{x:50,y:0,w:30,h:40}],
        [{x:0,y:0,w:30,h:60},{x:40,y:0,w:30,h:60}],
        [{x:0,y:0,w:30,h:50},{x:35,y:0,w:30,h:50},{x:70,y:0,w:30,h:50}],
        [{x:0,y:0,w:30,h:30},{x:40,y:0,w:30,h:60},{x:80,y:0,w:30,h:40}],
        [{x:0,y:0,w:30,h:70},{x:50,y:0,w:30,h:50},{x:100,y:0,w:30,h:30}],
        [{x:0,y:0,w:30,h:40},{x:30,y:0,w:30,h:40},{x:60,y:0,w:30,h:40}],
        [{x:0,y:0,w:30,h:60},{x:45,y:0,w:30,h:60},{x:90,y:0,w:30,h:60}]
    ];
    const choice = patterns[Math.floor(Math.random()*patterns.length)];
    choice.forEach(c => {
        obstacles.push({x:canvas.width + c.x, y:350 - c.h, w: c.w, h: c.h});
    });
}

// Collision detection
function checkCollision() {
    for(let i=0;i<obstacles.length;i++){
        let obs = obstacles[i];
        if(player.x < obs.x + obs.w &&
           player.x + player.w > obs.x &&
           player.y < obs.y + obs.h &&
           player.y + player.h > obs.y) {
               gameOver = true;
        }
    }
}

// Update score and speed
function updateScore() {
    score++;
    if(score > highScore) highScore = score;
    scoreEl.textContent = 'Score: ' + score;
    if(score % 400 === 0) speed += 0.5;
}

// Recycle platforms
function recyclePlatforms() {
    if(platforms[0].x + platforms[0].w < 0){
        let first = platforms.shift();
        let last = platforms[platforms.length-1];
        first.x = last.x + last.w + Math.random()*50;
        first.y = 350 - (Math.random()*50);
        first.w = 200 + Math.random()*100;
        platforms.push(first);
    }
}

// Game loop
function update() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();

    if(gameOver) {
        ctx.fillStyle = '#fff';
        ctx.font = '30px sans-serif';
        ctx.fillText('Game Over! Score: '+score, canvas.width/2-150, canvas.height/2);
        ctx.fillText('Click or press Space to restart', canvas.width/2-180, canvas.height/2+40);
        return;
    }

    // Player physics
    player.vy += gravity;
    player.y += player.vy;
    if(player.y + player.h >= 350){player.y = 350 - player.h; player.vy=0; player.jumping=false;}

    // Platforms
    platforms.forEach(p => { p.x -= speed; drawPlatforms(); });
    recyclePlatforms();

    // Obstacles
    spawnTimer++;
    if(spawnTimer > 80){ spawnObstacle(); spawnTimer = 0; }
    drawObstacles();
    checkCollision();

    // Player
    drawPlayer();

    // Score
    updateScore();

    requestAnimationFrame(update);
}

// Restart game
function restart() {
    if(gameOver) {
        resetGame();
        update();
    }
}

document.addEventListener('keydown', e=>{ if(e.code==='Space') restart(); });
canvas.addEventListener('click', restart);
</script>
</body>
</html>
