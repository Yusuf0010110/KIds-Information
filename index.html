<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometry Dash Ultimate - Yusuf</title>
<style>
body { margin:0; overflow:hidden; background:#111; font-family:sans-serif; }
canvas { display:block; margin:auto; background:#111; }
#score { position:absolute; top:20px; left:50%; transform:translateX(-50%); color:#0f0; font-size:24px; font-weight:bold; text-shadow:0 0 2px #000; }
#startScreen { position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; background:#111; color:#0f0; }
button { padding:15px 30px; font-size:20px; margin-top:20px; cursor:pointer; border:none; border-radius:10px; background:#0f0; color:#000; font-weight:bold; }
button:hover { background:#0a0; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="startScreen">
<h1>Geometry Dash Ultimate</h1>
<p>Click Play or press Space to start</p>
<button id="playBtn">Play</button>
</div>
<canvas id="game" width="800" height="400"></canvas>
<script>
// Canvas setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// DOM elements
const scoreEl = document.getElementById('score');
const startScreen = document.getElementById('startScreen');
const playBtn = document.getElementById('playBtn');

// Game state
let gameRunning = false;
let gameOver = false;
let score = 0;
let highScore = 0;
let speed = 5;
let spawnTimer = 0;

// Player
let player = { x:100, y:300, w:30, h:30, vy:0, jumping:false };

// Physics
const gravity = 0.8;
const jumpPower = -15;

// Platforms
let platforms = [{ x:0, y:350, w:canvas.width, h:50 }];

// Obstacles
let obstacles = [];

// Background layers
let bgLayers = [
    { x:0, y:0, w:canvas.width, h:canvas.height, speed:0.2, color:'#4400ff' },
    { x:0, y:0, w:canvas.width, h:canvas.height, speed:0.5, color:'#8800ff' },
    { x:0, y:0, w:canvas.width, h:canvas.height, speed:1, color:'#ff0088' }
];

// Controls
document.addEventListener('keydown', e=>{
    if(e.code==='Space'){
        if(!gameRunning) startGame();
        else jump();
    }
});
canvas.addEventListener('click', ()=>{
    if(!gameRunning) startGame();
    else jump();
});
playBtn.addEventListener('click', startGame);

// Start game
function startGame(){
    startScreen.style.display='none';
    gameRunning = true;
    resetGame();
    update();
}

// Reset
function resetGame(){
    player.y = 300; player.vy = 0; player.jumping = false;
    platforms = [{ x:0, y:350, w:canvas.width, h:50 }];
    obstacles = [];
    score = 0; spawnTimer = 0; speed = 5; gameOver = false;
}

// Jump
function jump(){
    if(!player.jumping){ player.vy = jumpPower; player.jumping = true; }
}

// Draw background
function drawBackground(){
    bgLayers.forEach(layer=>{
        ctx.fillStyle = layer.color;
        ctx.fillRect(layer.x, layer.y, layer.w, layer.h);
        ctx.fillRect(layer.x + canvas.width, layer.y, layer.w, layer.h);
        layer.x -= layer.speed;
        if(layer.x <= -canvas.width) layer.x = 0;
    });
}

// Draw platforms
function drawPlatforms(){
    platforms.forEach(p=>{
        ctx.fillStyle = '#0f0';
        ctx.fillRect(p.x, p.y, p.w, p.h);
    });
}

// Draw player
function drawPlayer(){
    ctx.fillStyle = '#0f0';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 3;
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.strokeRect(player.x, player.y, player.w, player.h);
}

// Draw spikes
function drawSpike(x,y,w,h){
    ctx.fillStyle = '#f00';
    ctx.beginPath();
    ctx.moveTo(x, y+h);
    ctx.lineTo(x+w/2, y);
    ctx.lineTo(x+w, y+h);
    ctx.closePath();
    ctx.fill();
}

// Draw obstacles
function drawObstacles(){
    obstacles.forEach(obs=>{
        drawSpike(obs.x, obs.y, obs.w, obs.h);
    });
}

// Spawn obstacles
function spawnObstacle(){
    const patterns = [
        [{x:0,y:0,w:30,h:30}],
        [{x:0,y:0,w:30,h:50}],
        [{x:0,y:0,w:30,h:70}],
        [{x:0,y:0,w:30,h:40},{x:50,y:0,w:30,h:40}],
        [{x:0,y:0,w:30,h:60},{x:40,y:0,w:30,h:60}],
        [{x:0,y:0,w:30,h:50},{x:35,y:0,w:30,h:50},{x:70,y:0,w:30,h:50}],
        [{x:0,y:0,w:30,h:30},{x:40,y:0,w:30,h:60},{x:80,y:0,w:30,h:40}],
        [{x:0,y:0,w:30,h:70},{x:50,y:0,w:30,h:50},{x:100,y:0,w:30,h:30}],
        [{x:0,y:0,w:30,h:40},{x:30,y:0,w:30,h:40},{x:60,y:0,w:30,h:40}],
        [{x:0,y:0,w:30,h:60},{x:45,y:0,w:30,h:60},{x:90,y:0,w:30,h:60}]
    ];
    const choice = patterns[Math.floor(Math.random()*patterns.length)];
    choice.forEach(c=>{
        obstacles.push({ x:canvas.width+c.x, y:350-c.h, w:c.w, h:c.h });
    });
}

// Check collision
function checkCollision(){
    obstacles.forEach(obs=>{
        if(player.x < obs.x + obs.w &&
           player.x + player.w > obs.x &&
           player.y < obs.y + obs.h &&
           player.y + player.h > obs.y){
               gameOver = true;
        }
    });
}

// Recycle platforms
function recyclePlatforms(){
    if(platforms[0].x + platforms[0].w < 0){
        let first = platforms.shift();
        let last = platforms[platforms.length-1];
        first.x = last.x + last.w + Math.random()*50;
        first.y = 350 - (Math.random()*50);
        first.w = 200 + Math.random()*100;
        platforms.push(first);
    }
}

// Update score
function updateScore(){
    score++;
    if(score>highScore) highScore=score;
    scoreEl.textContent='Score: '+score;
    if(score%400===0) speed +=0.5;
}

// Game loop
function update(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();
    drawPlatforms();

    if(gameOver){
        ctx.fillStyle='#fff';
        ctx.font='30px sans-serif';
        ctx.fillText('Game Over! Score: '+score, canvas.width/2-150, canvas.height/2);
        ctx.fillText('Click or press Space to restart', canvas.width/2-180, canvas.height/2+40);
        return;
    }

    // Player physics
    player.vy += gravity;
    player.y += player.vy;
    if(player.y+player.h >= 350){ player.y=350-player.h; player.vy=0; player.jumping=false; }

    // Platforms
    platforms.forEach(p=>{ p.x -= speed; });
    recyclePlatforms();

    // Obstacles
    spawnTimer++;
    if(spawnTimer>80){ spawnObstacle(); spawnTimer=0; }
    obstacles.forEach(obs=>{ obs.x -= speed; });
    drawObstacles();
    checkCollision();

    // Player
    drawPlayer();

    // Score
    updateScore();

    requestAnimationFrame(update);
}

// Restart game
function restart(){
    if(gameOver){ resetGame(); update(); }
}
document.addEventListener('keydown', e=>{ if(e.code==='Space') restart(); });
canvas.addEventListener('click', restart);
</script>
</body>
</html>
