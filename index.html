<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometry Dash Mini - Yusuf</title>
<style>
body {margin:0; overflow:hidden; background:#111; font-family:sans-serif;}
canvas {display:block; margin:auto; background:#000;}
#score {position:absolute; top:20px; left:50%; transform:translateX(-50%); color:#0af; font-size:24px; font-weight:bold;}
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="game" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Player
let player = {x:100, y:300, w:30, h:30, vy:0, jumping:false};

// Physics
let gravity = 0.8;
let jumpPower = -15;

// Obstacles and platforms
let obstacles = [];
let platforms = [];
platforms.push({x:0, y:350, w:canvas.width, h:50}); // initial ground

// Game state
let spawnTimer = 0;
let speed = 5;
let score = 0;
let gameOver = false;

// Controls
document.addEventListener('keydown', e=>{if(e.code==='Space') jump();});
canvas.addEventListener('click', jump);

function jump(){
  if(!player.jumping){player.vy = jumpPower; player.jumping=true;}
}

// Spawn obstacle
function spawnObstacle(){
  let height = 30 + Math.random()*40;
  obstacles.push({x:canvas.width, y:350-height, w:30, h:height});
}

// Draw spike
function drawSpike(x,y,w,h){
  ctx.fillStyle = '#f00';
  ctx.beginPath();
  ctx.moveTo(x,y+h);
  ctx.lineTo(x+w/2,y);
  ctx.lineTo(x+w,y+h);
  ctx.closePath();
  ctx.fill();
}

// Draw neon platform
function drawPlatform(p){
  ctx.fillStyle='#0af';
  ctx.fillRect(p.x,p.y,p.w,p.h);
}

// Draw background
function drawBackground(){
  ctx.fillStyle='linear-gradient(#000,#111)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

// Update game
function update(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(gameOver){
    ctx.fillStyle='#fff';
    ctx.font='30px sans-serif';
    ctx.fillText('Game Over! Score: '+score, canvas.width/2-140, canvas.height/2);
    return;
  }

  // Physics
  player.vy += gravity;
  player.y += player.vy;
  if(player.y + player.h >= 350){player.y = 350 - player.h; player.vy=0; player.jumping=false;}

  // Draw platforms
  platforms.forEach(p=>{
    drawPlatform(p);
    p.x -= speed;
  });

  // Recycle ground platform
  if(platforms[0].x + platforms[0].w < 0){
    platforms[0].x = platforms[platforms.length-1].x + platforms[platforms.length-1].w;
    platforms.push(platforms.shift());
  }

  // Spawn obstacles
  spawnTimer++;
  if(spawnTimer>90){
    spawnObstacle();
    spawnTimer=0;
  }

  // Draw obstacles
  for(let i=obstacles.length-1;i>=0;i--){
    obstacles[i].x -= speed;
    drawSpike(obstacles[i].x,obstacles[i].y,obstacles[i].w,obstacles[i].h);

    // Collision
    if(player.x<obstacles[i].x+obstacles[i].w &&
       player.x+player.w>obstacles[i].x &&
       player.y<obstacles[i].y+obstacles[i].h &&
       player.y+player.h>obstacles[i].y){
         gameOver=true;
    }

    // Remove offscreen
    if(obstacles[i].x+obstacles[i].w<0) obstacles.splice(i,1);
  }

  // Draw player cube
  ctx.fillStyle='#0ff';
  ctx.fillRect(player.x,player.y,player.w,player.h);

  // Score
  score++;
  document.getElementById('score').textContent='Score: '+score;

  // Gradually increase speed
  if(score%500===0) speed+=0.5;

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
