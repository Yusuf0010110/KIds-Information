<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometry Dash Full - Yusuf</title>
<style>
body {margin:0; overflow:hidden; background:#111; font-family:sans-serif;}
canvas {display:block; margin:auto; background:#000;}
#score {position:absolute; top:20px; left:50%; transform:translateX(-50%); color:#0af; font-size:24px; font-weight:bold; text-shadow: 0 0 10px #0ff;}
#startScreen {position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center; background:#111; color:#0af;}
button {padding:15px 30px; font-size:20px; margin-top:20px; cursor:pointer; border:none; border-radius:10px; background:#0af; color:#000; font-weight:bold;}
button:hover {background:#0ff;}
</style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="startScreen">
<h1>Geometry Dash Mini</h1>
<p>Click Play or press Space to start</p>
<button id="playBtn">Play</button>
</div>
<canvas id="game" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const startScreen = document.getElementById('startScreen');
const playBtn = document.getElementById('playBtn');

let gameRunning = false;

// Player
let player = {x:100, y:300, w:30, h:30, vy:0, jumping:false};

// Physics
let gravity = 0.8;
let jumpPower = -15;

// Platforms & obstacles
let platforms = [];
let obstacles = [];
platforms.push({x:0, y:350, w:canvas.width, h:50});

// Background layers for parallax
let bgLayers = [
  {x:0, y:0, w:canvas.width, h:canvas.height, speed:0.2, color:'#111'},
  {x:0, y:0, w:canvas.width, h:canvas.height, speed:0.5, color:'#222'},
  {x:0, y:0, w:canvas.width, h:canvas.height, speed:1, color:'#333'}
];

// Game state
let spawnTimer = 0;
let speed = 5;
let score = 0;
let highScore = 0;
let gameOver = false;

// Controls
document.addEventListener('keydown', e=>{
  if(e.code==='Space'){
    if(!gameRunning) startGame();
    else jump();
  }
});
canvas.addEventListener('click', ()=>{
  if(!gameRunning) startGame();
  else jump();
});
playBtn.addEventListener('click', startGame);

function startGame(){
  startScreen.style.display='none';
  gameRunning=true;
  resetGame();
  update();
}

function resetGame(){
  player.y=300; player.vy=0; player.jumping=false;
  obstacles=[]; platforms=[{x:0,y:350,w:canvas.width,h:50}];
  spawnTimer=0; speed=5; score=0; gameOver=false;
}

function jump(){
  if(!player.jumping){player.vy=jumpPower; player.jumping=true;}
}

function spawnObstacle(){
  const patterns = [
    {w:30,h:30},{w:30,h:50},{w:30,h:70},{w:30,h:40},{w:30,h:60}
  ];
  const choice = patterns[Math.floor(Math.random()*patterns.length)];
  obstacles.push({x:canvas.width, y:350-choice.h, w:choice.w, h:choice.h});
}

function drawSpike(x,y,w,h){
  ctx.fillStyle='#f00';
  ctx.beginPath();
  ctx.moveTo(x,y+h);
  ctx.lineTo(x+w/2,y);
  ctx.lineTo(x+w,y+h);
  ctx.closePath();
  ctx.fill();
}

function drawPlatform(p){
  ctx.fillStyle='#0af';
  ctx.shadowColor='#0ff';
  ctx.shadowBlur=15;
  ctx.fillRect(p.x,p.y,p.w,p.h);
  ctx.shadowBlur=0;
}

function drawBackground(){
  bgLayers.forEach(layer=>{
    ctx.fillStyle=layer.color;
    ctx.fillRect(layer.x,layer.y,layer.w,layer.h);
    layer.x-=layer.speed;
    if(layer.x<=-canvas.width) layer.x=0;
  });
}

function update(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();

  if(gameOver){
    ctx.fillStyle='#fff';
    ctx.font='30px sans-serif';
    ctx.fillText('Game Over! Score: '+score, canvas.width/2-150, canvas.height/2);
    ctx.fillText('Click or press Space to restart', canvas.width/2-180, canvas.height/2+40);
    return;
  }

  // Player physics
  player.vy += gravity;
  player.y += player.vy;
  if(player.y+player.h>=350){player.y=350-player.h; player.vy=0; player.jumping=false;}

  // Platforms
  platforms.forEach(p=>{
    drawPlatform(p);
    p.x -= speed;
  });

  // Recycle platforms
  if(platforms[0].x+platforms[0].w<0){
    platforms[0].x = platforms[platforms.length-1].x + platforms[platforms.length-1].w;
    platforms.push(platforms.shift());
  }

  // Obstacles
  spawnTimer++;
  if(spawnTimer>80){spawnObstacle(); spawnTimer=0;}

  for(let i=obstacles.length-1;i>=0;i--){
    obstacles[i].x -= speed;
    drawSpike(obstacles[i].x,obstacles[i].y,obstacles[i].w,obstacles[i].h);

    // Collision
    if(player.x<obstacles[i].x+obstacles[i].w &&
       player.x+player.w>obstacles[i].x &&
       player.y<obstacles[i].y+obstacles[i].h &&
       player.y+player.h>obstacles[i].y){
         gameOver=true;
    }

    if(obstacles[i].x+obstacles[i].w<0) obstacles.splice(i,1);
  }

  // Draw player
  ctx.fillStyle='#0ff';
  ctx.shadowColor='#0ff';
  ctx.shadowBlur=25;
  ctx.fillRect(player.x,player.y,player.w,player.h);
  ctx.shadowBlur=0;

  // Score
  score++;
  if(score>highScore) highScore=score;
  scoreEl.textContent='Score: '+score;

  // Increase speed
  if(score%400===0) speed+=0.5;

  requestAnimationFrame(update);
}

</script>
</body>
</html>
